<!DOCTYPE html>
<html>
<head>
<meta charset="UTF-8">
<title>选择排序</title>
</head>
<body style="background-color: #ffb6c1;">
<div style="height: 80px;">
<h1 style="padding-top: 30px; color: red;" align="center">Java中的经典算法之选择排序（SelectionSort）</h1>
</div>
<div style="height: 30px"></div>
<div>
<b style="color: green;">a) 原理：</b>每一趟从待排序的记录中选出最小的元素，顺序放在已排好序的序列最后，直到全部记录排序完毕。也就是：每一趟在n-i+1(i=1，2，…n-1)个记录中选取关键字最小的记录作为有序序列中第i个记录。基于此思想的算法主要有简单选择排序、树型选择排序和堆排序。（这里只介绍常用的简单选择排序）<br /><br /><br />

<b style="color: green;">b) 简单选择排序的基本思想：</b>给定数组：int[] arr={里面n个数据}；第1趟排序，在待排序数据arr[1]~arr[n]中选出最小的数据，将它与arrr[1]交换；第2趟，在待排序数据arr[2]~arr[n]中选出最小的数据，将它与r[2]交换；以此类推，第i趟在待排序数据arr[i]~arr[n]中选出最小的数据，将它与r[i]交换，直到全部排序完成。<br /><br />

<b style="color: green;">c) 举例：</b>数组 int[] arr={5,2,8,4,9,1};<br />

-------------------------------------------------------<br />

第一趟排序： 原始数据：5  2  8  4  9  1<br /><br />

最小数据1，把1放在首位，也就是1和5互换位置，<br />

排序结果：1  2  8  4  9  5<br />

-------------------------------------------------------<br />

第二趟排序：<br /><br />

第1以外的数据{2  8  4  9  5}进行比较，2最小，<br />

排序结果：1  2  8  4  9  5<br />

-------------------------------------------------------<br />

第三趟排序：<br /><br />

除1、2以外的数据{8  4  9  5}进行比较，4最小，8和4交换<br />

排序结果：1  2  4  8  9  5<br />

-------------------------------------------------------<br />

第四趟排序：<br /><br />

除第1、2、4以外的其他数据{8  9  5}进行比较，5最小，8和5交换<br />

排序结果：1  2  4  5  9  8<br />

-------------------------------------------------------<br />

第五趟排序：<br /><br />

除第1、2、4、5以外的其他数据{9  8}进行比较，8最小，8和9交换<br />

排序结果：1  2  4  5  8  9<br />

-------------------------------------------------------<br />

注：每一趟排序获得最小数的方法：for循环进行比较，定义一个第三个变量temp，首先前两个数比较，把较小的数放在temp中，然后用temp再去跟剩下的数据比较，如果出现比temp小的数据，就用它代替temp中原有的数据。具体参照后面的代码示例，相信你在学排序之前已经学过for循环语句了，这样的话，这里理解起来就特别容易了。<br /><br /><br /><br />
<strong>代码示例：</strong>
<br /><br />
<code>
//选择排序
public class SelectionSort {<br />
    public static void main(String[] args) {<br />
        int[] arr={1,3,2,45,65,33,12};<br />
        System.out.println("交换之前：");<br />
        for(int num:arr){<br />
            System.out.print(num+" ");<br />
        }        
        //选择排序的优化<br />
        for(int i = 0; i < arr.length - 1; i++) {// 做第i趟排序<br />
            int k = i;
            for(int j = k + 1; j < arr.length; j++){// 选最小的记录<br />
                if(arr[j] < arr[k]){ <br />
                    k = j; //记下目前找到的最小值所在的位置<br />
                }
            }<br />
            //在内层循环结束，也就是找到本轮循环的最小的数以后，再进行交换<br />
            if(i != k){  //交换a[i]和a[k]<br />
                int temp = arr[i];<br />
                arr[i] = arr[k];<br />
                arr[k] = temp;
            }    <br />
        }
        System.out.println();<br />
        System.out.println("交换后：");<br />
        for(int num:arr){<br />
            System.out.print(num+" ");<br />
        }
    }<br />
}
</code>
</div>
<div style="height: 15px" ></div>
<div>
<strong>运行结果如下：</strong><br />
<h3 style="color:blue;">交换之前；</h3>
1 &nbsp;&nbsp;3&nbsp;&nbsp;2&nbsp;&nbsp;45&nbsp;&nbsp;65&nbsp;&nbsp;32&nbsp;&nbsp;12<br />
<h3 style="color:blue;">交换之后；</h3>
1 &nbsp;&nbsp;2&nbsp;&nbsp;3&nbsp;&nbsp;12&nbsp;&nbsp;32&nbsp;&nbsp;45&nbsp;&nbsp;65<br /><br /><br />
<p>选择排序的时间复杂度：简单选择排序的比较次数与序列的初始排序无关。 假设待排序的序列有 N 个元素，则比较次数永远都是N (N - 1) / 2。而移动次数与序列的初始排序有关。当序列正序时，移动次数最少，为 0。当序列反序时，移动次数最多，为3N (N - 1) /  2。

所以，综上，简单排序的时间复杂度为 O(N2)。</p>
</div>

</body>
</html>