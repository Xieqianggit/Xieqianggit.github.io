<!DOCTYPE html>
<html>
<head>
<meta charset="UTF-8">
<title>Java常用排序算法小结</title>
</head>
<body>
<div><p>&nbsp;&nbsp;&nbsp;当我们进行数据处理的时候，往往需要对数据进行查找操作，一个有序的数据集往往能够在高效的查找算法下快速得到结果。<br /><br />所以排序的效率就会显的十分重要，本篇我们将着重的介绍几个常见的排序算法，涉及如下内容：</p><br /></div>
<div style="height:10px;"></div>
<div>
<ui>
<li>排序相关的概念</li>
<li>选择类排序</li>
<li>交换类排序</li>
</ui>
</div>
<div style="height:10px;"></div>
<div>
<h4>一、排序相关的基本概念</h4>
 <p>&nbsp;&nbsp;&nbsp;&nbsp; 排序其实是一个相当大的概念，主要分为两类：内部排序和外部排序。而我们通常所说的各种排序算法其实指的是内部排序算法。<br />内部排序是基于内存的，整个排序过程都是在内存中完成的，而外部排序指的是由于数据量太大，内存不能完全容纳，排序的时候需要借助外存才能完成（常常是算计着某一部分已经计算过的数据移出内存让另一部分未被计算的数据进入内存）。<br />而我们本篇文章将主要介绍内排序中的几种常用排序算法：<br />还有一个概念问题，排序的稳定性问题。如果Ai = Aj，排序前Ai在Aj之前，排序后Ai还在Aj之前，则称这种排序算法是稳定的，否则说明该算法不稳定。</p>
</div>
<div style="height:10px;"></div>
<div>
<h4 style="color: red;">1.交换类排序</h4><br />
 交换类的排序算法一般是利用两个元素之间的值的大小进行比较运算，然后移动外置实现的，这类排序算法主要有两种：<br />
 <h6> 1、冒泡排序</h6>
 冒泡排序通过两两比较，每次将最大或者最小的元素移动到整个序列的一端。这种排序相当常见，也比较简单。具体可以看我的另一篇关于冒泡排序的详细介绍
 <br />github链接如下；<a href="Sorts/Bubblesort.html">冒泡排序详解</a><br />
 <h6> 2、快速排序</h6>
 快速排序的基本思想是，从序列中任选一个元素，但通常会直接选择序列的第一个元素作为一个标准，所有比该元素值小的元素全部移动到他的左边，比他大的都移动到他的右边。<br />我们称这叫做一趟快速排序，位于该元素两边的子表继续进行快速排序算法直到整个序列都有序。<br />该排序算法是目前为止，内部排序中效率最高的排序算法。本人再另一篇文章会有详细介绍。
 <br />github链接如下；<a href="Sorts/Quicksort.html">快速排序详解</a><br />
 <h4 style="color: red;">2.选择类排序</h4>
  <p>选择类排序的基本思想是，每一趟会在n个元素中比较n-1次，选择出最大或者最小的一个元素放在整个序列的端点处。<br />选择类排序有基于树的也有基于线性表的，有关树结构的各种排序算法，我将在后续文章中进行详细描述，此处提供github链接地址：<br />
  github链接如下；<a href="Sorts/Selectionsort.html">选择排序详解</a><br /><br />
  <strong>&nbsp;&nbsp;&nbsp;&nbsp;至此，线性的基本排序算法都已经介绍完成了，有些算法介绍的比较粗糙，待后续深入理解后再回来补充，总结不到之处，望指出！</strong>
  
</div>
</body>
</html>